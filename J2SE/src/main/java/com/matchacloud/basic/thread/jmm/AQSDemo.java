package com.matchacloud.basic.thread.jmm;

/**
 * AQS讲解:
 * 1.AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器
 * 2.AQS是用于实现锁和同步器的公共基础部分的抽象实现
 * 3.主要解决锁分配给谁的问题
 * 4.AQS是实现juc并发编程的基石。AQS是抽象类 基础父类
 * 5.Java并发大神 Doug Lea 设计AQS 目的是为了实现锁和同步器框架，
 * 提出统一规范并简化了锁的实现方式，AQS是模版设计思想 相当于是实现了公共需求
 * 6.锁 面向锁的使用者。同步器 面向锁的实现者
 * <p>
 * ReentrantLock机制讲解：
 * 1.自旋锁是线程自己尝试获取锁，自旋锁适合锁持有时间极短的场景，避免线程上下文切换开销
 * 2.ReentrantLock公平锁时是线程获取不到锁线程本身先暂停等待，公平锁模式下几乎不会出现自旋
 * 3.ReentrantLock非公平锁时，线程获取锁时会短暂自旋
 * 4.在高并发场景中，优先使用 ReentrantLock 的默认实现，其自适应策略通常比手动实现的自旋锁更高效
 * 5.aqs来协调安排线程的暂停和唤醒
 * <p>
 * AQS同步队列的结构:
 * 1.双向链表 方便插、删元素 有头指针、尾指针
 * 2.同步队列每个节点结构：1 请求锁的线程 2 有一个属性等待状态 是描述每个线程的等待状态
 * 同一个同步队列中的线程都是抢同一把锁 这同一把锁的占用(获取)状态 用volatile修饰 表示是共享变量!!!
 * 一把锁(就是一个对象实例) 对应 一个同步队列(CLH队列)
 * <p>
 * 上锁/解锁原理：
 * 一开始，线程a上锁，这时锁没有被占用，线程a直接获取到锁并执行，
 * 这时 线程b上锁 利用cas机制尝试获取锁 发现失败 把线程b封装成一个Node节点入队到同步队列
 * 此时队列长这样：头节点(哨兵节点 不存储任何线程)  头节点的next是线程b
 * 此时线程b开始自旋 尝试获取锁 获取不到 则挂起 同时把头节点的waitstatus改为-1(表示头节点的next即线程b处于暂停状态)
 * 一段时间后线程a执行完毕 释放锁 释放成功后看头节点的waitstatus是-1说明有线程在等待(就是线程b) 这时唤醒线程b b再次自旋就获取锁了
 * 进入同步队列的节点 如果前驱不是头节点 一律阻塞线程，如果前驱是头节点 先自旋获取锁 失败了也阻塞
 * 也就是说 前驱是头节点的线程会自旋或挂起 其余节点全是挂起
 * <p>
 * 使用aqs机制的工具：
 * 1.ReentrantLock(为何可重入详见源码)上锁/解锁机制及线程的竞争锁底层是AQS实现的。
 * ReentrantLock公平/非公平锁区别详见源码
 * 2.CountDownLatch
 * 3.Semaphore
 * 4.CyclicBarrier
 */
public class AQSDemo {

}
