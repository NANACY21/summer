package com.matchacloud.basic.jvm;

/**
 * fullGC:
 * 1.Full GC 是 JVM中的一种垃圾回收机制，
 * 回收整个堆内存(包括新生代老年代永久代)中的垃圾对象。
 * 2.是一种相对耗时的操作，会暂停所有用户线程(无法处理新的请求)直到垃圾回收完成
 * 3.fullgc一般不会使jvm宕机，只是系统会明显的卡顿，极端场景会间接导致jvm宕机
 * fullgc时间过长，系统明显卡顿响应时间变长
 * 只要 Full GC 能够正常完成，回收掉足够的内存，JVM 通常可以继续正常运行
 * fullgc长时间无法完成，导致系统组件超时，影响系统稳定性，进而导致jvm宕机
 * 严重内存泄露，这时又有新对象产生，不断进行 Full GC，内存仍然不够，因此最终jvm宕机
 * 4.Full GC 除了回收垃圾对象，还会进行内存碎片整理等操作
 * 5.fullgc可能会对系统的稳定性和性能产生严重影响
 * 6.jvm调优有助于减少fullgc出现频率，解决运行慢、卡顿问题
 * <p>
 * 什么时候会触发fullGC:
 * 1.老年代空间不足时：当老年代中的对象占用空间达到一定阈值，无法为新晋升的对象分配空间时，
 * 会触发 Full GC，试图回收老年代中的垃圾对象以释放空间。
 * 2.永久代(元空间)空间不足时
 * 3.大对象直接进入老年代：如果创建了一个很大的对象，新生代的空间无法容纳，这个对象会直接进入老年代。
 * 如果老年代剩余空间也不足，就可能触发 Full GC
 * <p>
 * Full GC 的解决方法:
 * 1.调整堆内存大小：
 * 分析内存使用情况：使用 JVM 自带的工具(如 jstat、jmap 等)或第三方监控工具(如 VisualVM、JProfiler 等)分析内存使用情况，确定是否是堆内存过小导致频繁 Full GC。
 * 增大堆内存
 * 调整堆大小可以减少fullgc频率，降低系统延迟
 * 2.优化对象引用：
 * 检查代码中是否存在不必要的对象引用，导致对象无法被及时回收。
 * 确保在使用完对象后，及时将引用置为null，以便垃圾回收器能够回收该对象占用的内存。
 * 3.排查内存泄漏：使用内存分析工具(如 MAT)分析堆转储文件，查找可能存在的内存泄漏点。
 * 内存泄漏可能是由于静态变量持有大量对象、资源未正确关闭等原因导致。
 * 4.调整垃圾回收器参数
 * 5.优化代码逻辑：减少大对象的创建、优化集合类的使用
 */
public class FullGC {

    static {

        /**
         * 显式调用该方法时
         * 会建议 JVM的垃圾回收器 执行 Full GC，但 JVM 不一定会立即执行，只是将其作为一个 Full GC 的触发条件之一
         */
        System.gc();
    }
}
