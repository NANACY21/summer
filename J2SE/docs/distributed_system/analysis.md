### Java分布式系统cpu很高怎么排查
1. `监控：` `Linux系统top命令`查看 Java 进程的 CPU 使用率
2. 找出cpu高的Java进程：`ps -ef | grep java`
3. 找出cpu高的Java线程：使用`top -Hp <PID>`命令查看指定 Java 进程中各个线程的 CPU 使用率
   返回结果中找到cpu使用率高的线程id(TID) 这个线程id转成十六进制`printf "%x\n" <TID>`
4. 使用jstack命令获取 Java 进程的线程栈信息，并将其保存到一个文件中
   `jstack <PID> > thread_dump.txt`
5. 使用前面转换得到的 16 进制线程 ID，在线程栈信息文件thread_dump.txt中查找对应的线程栈信息
   `grep -A 30 <16进制TID> thread_dump.txt`
   通过查看该线程的线程栈信息，可以定位到高 CPU 线程正在执行的 Java 代码
6. 分析导致cpu占用率很高的代码问题：
    1. 死循环：代码中存在没有正确终止条件的循环，导致 CPU 一直处于高负载状态
    2. 复杂的计算逻辑：某些方法中包含复杂的计算逻辑，导致 CPU 消耗过高
    3. 锁竞争：多个线程竞争同一个锁，导致 CPU 在锁的获取和释放上消耗大量时间
7. 使用其他性能分析工具：`VisualVM`、`YourKit`这些工具可以更直观地展示 Java 进程的性能信息
8. 频繁gc也可能导致cpu过高 用`jstat -gc <PID> 1000 10` 查看 Java 进程的 GC 情况
   其中<PID>是 Java 进程的 PID，1000表示每隔 1000 毫秒输出一次 GC 信息，10表示输出 10 次
9. `非jvm问题导致`
    1. 数据库cpu占用率过高
    2. 缓存
    3. mq
    4. 网络问题
    5. 磁盘 I/O 压力


### 分布式系统全身检查
1. 全局监控：使用 Prometheus+Grafana 等工具建立全链路监控，关联各组件的 CPU 使用率
2. 时间窗口对齐：确认 CPU 峰值出现时，其他组件是否有异常（如数据库慢查询激增）
3. 流量压测：模拟高并发场景，复现问题并定位瓶颈
4. 日志关联：结合应用日志、数据库日志、系统日志，分析请求链中的耗时环节


### 高并发问题解决方案
1. 应用层面优化
    1. `异步处理`：将一些不需要立即处理的任务异步执行，避免阻塞主线程，提高系统的响应能力和吞吐量
    2. `限流`：限制系统的输入和输出流量，防止过多的请求导致系统崩溃
    3. `熔断和降级`：当依赖的服务出现问题时，通过熔断机制快速失败，避免级联故障；通过降级机制提供兜底的服务
       可以使用`Hystrix`
2. 缓存层面优化
    1. `使用本地缓存`：将经常访问的数据存储在应用程序的本地内存中，减少对远程存储的访问
    2. `分布式缓存`：将缓存数据分布在多个节点上，提高缓存的容量和并发访问能力
3. 数据库层面优化
    1. `数据库读写分离`：将读操作和写操作分离到不同的数据库实例上，减轻主数据库的压力
    2. `数据库分库分表`：将数据分散存储在多个数据库或表中，提高数据库的并发处理能力
4. 架构层面优化
    1. `负载均衡`：将请求均匀地分配到多个服务器上，避免单点故障和提高系统的可用性和性能
    2. `采用微服务架构`


### 线上出现OOM怎么排查定位
1. 出现超时 服务停止 服务挂掉 接口无法访问这些症状时考虑可能OOM
2. `定位出现OOM的进程`：
    1. OS日志
    2. 微服务的日志
    3. top命令查看各个进程内存占用情况
3. `模拟OOM`写一个循环 不停add元素到list 而且不使用该list
4. 使用Java VisualVM分析 有一个visual GC插件 安装/激活该插件 看到堆空间使用情况
5. dump堆信息：会生成一个.hprof快照文件
6. 安装好MAT后 使用MAT分析hprof文件 能帮助定位问题 定位代码位置
7. 在服务器上获取堆内存dump文件：jmap -dump:format=b,file= <filename.hprof> <pid>
   自动生成堆内存dump文件：-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap/heapdump.hprof
8. 检查代码内存泄露、大对象等
9. 检查jvm进程堆内存大小是否合理
10. 系统运行全局监控工具