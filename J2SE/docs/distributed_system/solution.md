### 分布式锁
`线程锁：`如synchronized关键字、可重入锁api等，是多线程并发访问共享资源引起线程安全问题的一种解决方案  
`jvm本地锁：`对于一个服务节点，多个请求，请求共享资源(数据库的数据或内存数据) 可以使用synchronized关键字，或者可重入锁api  
**jvm本地锁3种失效场景**
1. service不是单例
2. 有事务。一个请求的开启的事务还没提交 另一个请求获取锁成功
3. 集群部署。不会是单例了

分布式锁，应用于分布式系统，多进程并发访问共享资源引起数据错误问题的一种解决方案，分布式锁实现方式3种：Redis，MySQL，Zookeeper  
场景：数据库里有一个字段值为10，对该字段操作，对于分布式系统，会有集群，用户的请求打到不同的进程  
这时，如果依然使用synchronized关键字显然不能再保护共享资源，这时就需要用到分布式锁，一个进程修改数据时  
其他进程不能修改这个数据，分布式锁就是解决这个问题的  

**分布式锁实现方案1(基于mysql)**  
基于mysql悲观锁：类似多线程并发的同步关键字，多个客户端请求同时访问不同进程，多个进程并发访问数据库，对于修改的记录(共享资源)，修改前加排他锁，类似同步锁，进程1获取到了锁执行sql，(其实本质就是mysql多个连接的并发)  
进程2获取不到锁则作出响应  
mysql innodb存储引擎，select for update，查询结果的数据被锁定(启用了排他锁 获取到了锁)，必须当前事务提交之后释放锁，这时其他阻塞的连接才能执行  
基于mysql乐观锁：乐观并发控制，不使用锁，使用版本号的概念，每次数据更新会伴随一个版本号。有点像cas，volatile  
**分布式锁实现方案2(基于redis)**  
见redis.md-分布式锁


### 分布式事务
`事务`:原子性，要么全部成功，要么全部失败
`分布式事务`:分布式事务的这些操作位于不同的服务(进程)中  
微服务a db操作，微服务b db操作，某业务场景这两个db操作组成了一个分布式事务
场景：下单操作包含生成订单+库存-1，使用分布式事务来保证数据一致性
分布式事务也是事务，也要保证：原子性 一致性 隔离性 持久性

可能影响分布式事务的因素：
1. 网络问题
2. 数据一致性
3. 性能问题

**分布式事务要遵循CAP理论**  
1. C(consistency) 一致性
    1. 强一致性：数据时时刻刻都是对的
    2. 最终一致性：数据最终是对的 比如订单生成后 过一会儿库存-1
2. A(availability) 可用性：保证分布式系统的可用
3. P(partition tolerance) 分区容忍性：网络故障导致节点通信受影响时还能满足分布式系统的一致性、可用性

如何确保分区容忍性：
1. 数据冗余与复制
2. 弹性网络拓扑
3. 分布式一致性算法

**但，CAP不能同时满足，P是一定要满足的刚性原则**
1. CP：zookeeper 满足一致性、分区容忍性。刚性事务需要满足CP，对数据要求强一致性  
    对于注重一致性的分布式系统要满足CP
2. AP：eureka(Spring cloud组件)满足可用性、分区容忍性。柔性事务需要满足AP，不同节点的数据暂时不一致，但最终是一致的。base理论：满足可用性和分区容错性的同时，满足弱一致性(最终一致性，不立刻一致，过一段时间再一致)  
    对于注重可用性的分布式系统要满足AP
3. CA：不可采用，不满足分区容忍性就违反了分布式架构的意义。


分布式事务当中大部分都用到AP+base理论  
针对以上理论，衍生出了分布式事务的一些解决思想，如：XA，2PC，TCC等  
针对这些解决思想有衍生出了一些分布式事务框架，如：阿里巴巴开源的seata，LCN，这两种框架都可以解决分布式事务  

**分布式事务的实践操作**
1. 对于注重一致性的分布式系统 如何设计分布式事务
2. 对于注重可用性的分布式系统 如何设计分布式事务
    1. 使用消息队列：异步解耦 消息重试机制

确保数据最终一致性：
1. 定时任务 在业务低谷期对数据刷新校正
2. 建立对账程序 定时任务方式运行以校正各方面数据
3. 还可以建立监控平台 监控分布式事务的执行状态 监控mq是否消息堆积
4. 建立补偿机制 运行补偿任务

[分布式系统各节点状态同步](https://juejin.im/post/5c974072f265da60d428fadd)