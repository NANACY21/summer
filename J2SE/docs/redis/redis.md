### Redis概述
1. `使用缓存的好处` 提升查询效率 减轻数据库的并发压力
2. `redis单线程` 当存在多个请求时 多个请求串行执行! 一个redis进程里只有一个处理请求的线程


### 缓存穿透解决方案
1. `缓存穿透`：数据在缓存和数据库中均不存在，造成数据库压力
   缓存穿透会增加mysql压力，数据库操作耗时从而影响系统响应时间
2. `缓存空对象`：当查询的数据在数据库中不存在时，也将一个空对象（如 null 或特定的空数据标识）缓存到 Redis 中，
   并设置一个较短的过期时间。这样下次相同的请求就可以直接从缓存中获取空对象，避免再次访问数据库
3. `接口层校验`
   在接口层对请求参数进行严格的校验，过滤掉明显非法的请求，如请求的键格式不符合要求等。这样可以在请求到达缓存和数据库之前就将其拦截，减少不必要的查询
4. `对于热点数据`：可以采用 “缓存永不过期” 的策略，即逻辑上不设置过期时间，而是在更新数据库时主动更新缓存。
   同时，为了防止缓存占用过多内存，可以使用 LRU（Least Recently Used，最近最少使用）等缓存淘汰策略。
   另外，对于热点数据的缓存失效时间可以采用随机化的方式，避免集体失效
5. `对于热点数据进行多级缓存`
   多级缓存可以将数据存储在不同层次的缓存中，例如本地缓存（如 Guava Cache）和分布式缓存（如 Redis）。
   当请求到来时，首先从本地缓存中查找，如果未命中再从分布式缓存中查找，最后才访问数据库。
   这样可以减少对分布式缓存和数据库的访问压力，提高系统的响应速度
6. `分布式锁` 相当于设置一个屏障 使得类似串行访问mysql 这起到了缓解数据库压力的作用。
7. `布隆过滤器(不了解)`
   布隆过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否存在于一个集合中。
   在查询缓存之前，先通过布隆过滤器判断该键是否可能存在。如果布隆过滤器认为键不存在，那么可以直接返回，避免访问数据库


### 缓存雪崩解决方案
1. `缓存雪崩`：大量缓存数据在同一时间过期或失效，导致大量请求直接穿透缓存，涌向数据库，从而可能使数据库因压力过大而崩溃的情况
   缓存雪崩会使mysql压力过大
2. `避免必要的缓存数据消失`：在应用程序中定期主动更新缓存数据，而不是等到缓存过期后再去更新。
   保证缓存数据的及时性和一致性
3. 避免一开始没有缓存数据 mysql会在一开始压力过大 预先写入缓存
4. 定时预热：设置定时任务，在业务低峰期定期对缓存进行预热。
   例如，每天凌晨 2 - 3 点，系统自动查询并更新第二天可能会用到的热点数据缓存，确保在业务高峰期来临时，缓存中有足够的数据可以响应请求
5. 增强数据库的抗压能力
    1. 数据库集群
    2. 限流与降级：对数据库的请求进行限流，当请求量超过数据库的处理能力时，拒绝部分请求或返回默认数据，
       以保护数据库。同时，可以根据数据库的负载情况，对一些非核心业务进行降级处理，暂停或降低这些业务对数据库的访问频率，确保核心业务的正常运行


### 5种数据类型
1. value有5种数据类型,关注5种数据类型的使用场景
2. `String`
3. `List`:底层使用链表 头插、尾插时间复杂度常数级别 定位元素比较慢
4. `Hash`:类似HashMap
5. `Set`:无序集合，集合元素是唯一的 类似list列表
6. `ZSet`:有序集合，已排序，集合元素是唯一的


### 缓存淘汰策略  
1. Redis缓存淘汰策略主要是通过Redis的内存淘汰机制来实现的。被淘汰的 key 通常会被删除，Redis提供了以下几种淘汰策略：
2. `noeviction`: 不进行淘汰，当内存不足时，新写入命令会报错
3. `allkeys-lru`: 当内存不足以容纳更多数据时，使用最近最少使用算法(LRU)进行淘汰
4. `allkeys-random`: 随机淘汰键
5. `volatile-lru`: 只对设置了过期时间的键进行LRU淘汰
6. `volatile-random`: 随机淘汰设置了过期时间的键
7. `volatile-ttl`: 淘汰即将过期的键，优先淘汰TTL更短的键。如果它的过期时间还未到，在某些情况下 Redis 可能不会立即删除它，而是标记该 key 为待删除状态
   减少不必要的删除，提高性能


### 设置淘汰策略
1. Redis配置文件中设置：`maxmemory-policy allkeys-lru`
2. `CONFIG SET命令`动态设置淘汰策略  
   设置为`allkeys-lru`策略：`redis-cli CONFIG SET maxmemory-policy allkeys-lru`
3. 实际应用中，可以根据应用的需求选择合适的淘汰策略：
    1. 如果应用对数据一致性要求不高，可以选择allkeys-random策略随机淘汰键，以保证数据的均匀分布在缓存中  
    2. 如果希望淘汰最近最少使用的数据，可以选择allkeys-lru策略  
    3. 如果希望优先淘汰即将过期的数据，可以选择volatile-ttl策略


### key的过期清理机制
1. `定期删除` 每隔一段时间执行一次定期删除操作(随机抽取一部分key 检查其中过期的key 删除并释放内存空间),因此不能保证所有过期key都能立即被删除并释放内存空间!!!
2. `惰性删除` 访问某一个key的时候 检查它是否过期 过期则删除并释放内存空间


### 数据类型使用演示
**String类型**  
1. `set name "huanhuanhello"` 新的键值对  
2. `get name` 获取指定键的值  
3. `getrange name 2 5` 获取键name指定索引范围的值  
4. `getset info AAAA` 修改键info的值，返回info旧值 键info若之前不存在，返回空，但已新增了键info并有了值  
5. `setex bb 10 bbbb` 键bb生存10秒  
6. `mset key1 "hello" key2 "world"` 批量设置键值

**list类型**  
1. `lpush hobbys redis` 向hobbys列表头插入值redis  
2. `rpush hobbys java` 向hobbys列表尾部插入值java  
3. `lrange hobbys 0 4` 显示hobbys列表 索引0 - 索引4 范围的值

**set类型**  
1. `sadd strs abc` 向strs列表插入值abc  
2. `sadd strs qwe tyu abc` 向strs列表插入值qwe、tyu、abc  
3. `smembers strs` 显示列表中所有的值  

**zset类型**  
1. `zadd ball 0 fooball` 向ball列表的索引0处插入值football  
2. `zadd ball 20 vollyball` 索引越界则默认插入到最后  
3. `zrange ball 0 100` 显示列表中指定索引范围的值  
4. `zrangebyscore ball 0 10` 显示列表索引0 - 10的数据并显示数据的序号

**hash类型**  
1. `HMSET person:1 name huanhuan age 21 sex male` 哈希表中有多对键值对  
2. `hgetall person:1` 获取指定哈希表的所有键值对  


### 其他Redis命令
1. `keys *` 列出所有的key  
2. `flushall` 清空所有数据


### 主主复制主从复制
1. Redis主从复制，也叫master-slaves配置，可以更好地读写分离


### 集群配置


### 三种集群模式


### 单点故障
1. 一个master节点有问题，其slave机器都完了，因此设置多个master节点。单线程，原子性


### 实现分布式锁
1. `分布式锁介绍`
   分布式锁的设计 redis分布式锁适用于集群场景，单实例使用jvm锁即可
   setnx命令，获取到锁，执行。获取不到锁，阻塞/返回/重试 思考：lock和trylock的区别
2. `可能存在的问题`
    1. redis分布式锁续期具体实现 业务时间过长redis分布式锁失效导致并发问题如何延长锁时间
    2. 分布式锁redis集群某实例坏了导致分布式锁失效:
       缓存集群是主从服务，主set key之后，从复制数据，会有io操作，耗时，一个连接获取到锁之后主挂了，从变成主但是还没来得及主从复制，另一个连接在主set key    
       成功竟然获取到锁了，导致分布式锁失效(redis集群不保证数据的高一致性)
       针对以上分布式锁失效场景，redisson通过redlock算法(上锁 保证所有redis节点都set成功才返回上锁成功 强一致性)，redis特有
    3. 因为业务执行时间过长导致锁过期从而导致并发问题 ：线程1释放锁 释放的是线程2持有的锁 因为锁是同一把(redis的同一个key) 这个要避免：使用uuid
3. `redisson` redis提供的分布式锁框架
    1. redisson是线程id和uuid绑定一起 从而保证线程不会释放另一个线程的锁
    2. watch dog看门狗：redis分布式锁续期具体实现 解决了锁过期但是业务没执行完的问题
    3. 兼容redis集群场景 集群场景只会向一个节点设置锁 返回上锁结果 然后集群内部后续进行主从同步
    4. 获取锁是自旋锁机制


### 不同数据类型的应用场景