### Redis概述
1. `使用缓存的好处` 提升查询效率 减轻数据库的并发压力
2. `redis单线程` 当存在多个请求时 多个请求串行执行! 一个redis进程里只有一个处理请求的线程


### 缓存穿透解决方案
1. `缓存穿透`：数据在缓存和数据库中均不存在，造成数据库压力
   缓存穿透会增加mysql压力，数据库操作耗时从而影响系统响应时间
2. `缓存空对象`：当查询的数据在数据库中不存在时，也将一个空对象（如 null 或特定的空数据标识）缓存到 Redis 中，
   并设置一个较短的过期时间。这样下次相同的请求就可以直接从缓存中获取空对象，避免再次访问数据库
3. `接口层校验`
   在接口层对请求参数进行严格的校验，过滤掉明显非法的请求，如请求的键格式不符合要求等。这样可以在请求到达缓存和数据库之前就将其拦截，减少不必要的查询
4. `对于热点数据`：可以采用 “缓存永不过期” 的策略，即逻辑上不设置过期时间，而是在更新数据库时主动更新缓存。
   同时，为了防止缓存占用过多内存，可以使用 LRU（Least Recently Used，最近最少使用）等缓存淘汰策略。
   另外，对于热点数据的缓存失效时间可以采用随机化的方式，避免集体失效
5. `对于热点数据进行多级缓存`
   多级缓存可以将数据存储在不同层次的缓存中，例如本地缓存（如 Guava Cache）和分布式缓存（如 Redis）。
   当请求到来时，首先从本地缓存中查找，如果未命中再从分布式缓存中查找，最后才访问数据库。
   这样可以减少对分布式缓存和数据库的访问压力，提高系统的响应速度
6. `分布式锁` 相当于设置一个屏障 使得类似串行访问mysql 这起到了缓解数据库压力的作用。
7. `布隆过滤器(不了解)`
   布隆过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否存在于一个集合中。
   在查询缓存之前，先通过布隆过滤器判断该键是否可能存在。如果布隆过滤器认为键不存在，那么可以直接返回，避免访问数据库


### 缓存雪崩解决方案
1. `缓存雪崩`：大量缓存数据在同一时间过期或失效，导致大量请求直接穿透缓存，涌向数据库，从而可能使数据库因压力过大而崩溃的情况
   缓存雪崩会使mysql压力过大
2. `避免必要的缓存数据消失`：在应用程序中定期主动更新缓存数据，而不是等到缓存过期后再去更新。
   保证缓存数据的及时性和一致性
3. 避免一开始没有缓存数据 mysql会在一开始压力过大 预先写入缓存
4. 定时预热：设置定时任务，在业务低峰期定期对缓存进行预热。
   例如，每天凌晨 2 - 3 点，系统自动查询并更新第二天可能会用到的热点数据缓存，确保在业务高峰期来临时，缓存中有足够的数据可以响应请求
5. 增强数据库的抗压能力
    1. 数据库集群
    2. 限流与降级：对数据库的请求进行限流，当请求量超过数据库的处理能力时，拒绝部分请求或返回默认数据，
       以保护数据库。同时，可以根据数据库的负载情况，对一些非核心业务进行降级处理，暂停或降低这些业务对数据库的访问频率，确保核心业务的正常运行


### 5种数据类型
1. value有5种数据类型,关注5种数据类型的使用场景
2. `String`
3. `List`:底层使用链表 头插、尾插时间复杂度常数级别 定位元素比较慢
4. `Hash`:类似HashMap
5. `Set`:无序集合，集合元素是唯一的 类似list列表
6. `ZSet`:有序集合，已排序，集合元素是唯一的


### 缓存淘汰策略  
1. Redis缓存淘汰策略主要是通过Redis的内存淘汰机制来实现的。被淘汰的 key 通常会被删除，Redis提供了以下几种淘汰策略：
2. `noeviction`: 不进行淘汰，当内存不足时，新写入命令会报错
3. `allkeys-lru`: 当内存不足以容纳更多数据时，使用最近最少使用算法(LRU)进行淘汰
4. `allkeys-random`: 随机淘汰键
5. `volatile-lru`: 只对设置了过期时间的键进行LRU淘汰
6. `volatile-random`: 随机淘汰设置了过期时间的键
7. `volatile-ttl`: 淘汰即将过期的键，优先淘汰TTL更短的键。如果它的过期时间还未到，在某些情况下 Redis 可能不会立即删除它，而是标记该 key 为待删除状态
   减少不必要的删除，提高性能


### 设置淘汰策略
1. Redis配置文件中设置：`maxmemory-policy allkeys-lru`
2. `CONFIG SET命令`动态设置淘汰策略  
   设置为`allkeys-lru`策略：`redis-cli CONFIG SET maxmemory-policy allkeys-lru`
3. 实际应用中，可以根据应用的需求选择合适的淘汰策略：
    1. 如果应用对数据一致性要求不高，可以选择allkeys-random策略随机淘汰键，以保证数据的均匀分布在缓存中  
    2. 如果希望淘汰最近最少使用的数据，可以选择allkeys-lru策略  
    3. 如果希望优先淘汰即将过期的数据，可以选择volatile-ttl策略


### key的过期清理机制
1. `定期删除` 每隔一段时间执行一次定期删除操作(随机抽取一部分key 检查其中过期的key 删除并释放内存空间),因此不能保证所有过期key都能立即被删除并释放内存空间!!!
2. `惰性删除` 访问某一个key的时候 检查它是否过期 过期则删除并释放内存空间


### 数据类型使用演示
**String类型**  
1. `set name "huanhuanhello"` 新的键值对  
2. `get name` 获取指定键的值  
3. `getrange name 2 5` 获取键name指定索引范围的值  
4. `getset info AAAA` 修改键info的值，返回info旧值 键info若之前不存在，返回空，但已新增了键info并有了值  
5. `setex bb 10 bbbb` 键bb生存10秒  
6. `mset key1 "hello" key2 "world"` 批量设置键值

**list类型**  
1. `lpush hobbys redis` 向hobbys列表头插入值redis  
2. `rpush hobbys java` 向hobbys列表尾部插入值java  
3. `lrange hobbys 0 4` 显示hobbys列表 索引0 - 索引4 范围的值

**set类型**  
1. `sadd strs abc` 向strs列表插入值abc  
2. `sadd strs qwe tyu abc` 向strs列表插入值qwe、tyu、abc  
3. `smembers strs` 显示列表中所有的值  

**zset类型**  
1. `zadd ball 0 fooball` 向ball列表的索引0处插入值football  
2. `zadd ball 20 vollyball` 索引越界则默认插入到最后  
3. `zrange ball 0 100` 显示列表中指定索引范围的值  
4. `zrangebyscore ball 0 10` 显示列表索引0 - 10的数据并显示数据的序号

**hash类型**  
1. `HMSET person:1 name huanhuan age 21 sex male` 哈希表中有多对键值对  
2. `hgetall person:1` 获取指定哈希表的所有键值对  


### 其他Redis命令
1. `keys *` 列出所有的key  
2. `flushall` 清空所有数据


### 主主复制主从复制
1. Redis主从复制，也叫master-slaves配置，可以更好地读写分离


### 集群配置


### 三种集群模式
1. `主从模式`
    1. `一主节点`和`多从节点`组成，`主节点负责所有写、部分读`，从节点复制主节点的数据，`从节点负责所有读请求`和在主节点故障时进行故障转移
    2. 应用场景：`高可用性较低`，`适用于读多写少的场景`，如缓存系统。`通过增加从节点，可以提高系统的读性能`，同时主节点负责写操作，保证了数据的一致性
    3. 主节点包含了整个数据集 主从节点数据会最终一致
    4. 故障检测：主从复制模式下，从节点会定期向主节点发送命令请求，通过检查与主节点的连接状态以及是否能正常接收主节点的数据更新来判断主节点是否故障。同时，主节点也会记录从节点的连接和同步状态。如果从节点长时间没有收到主节点的响应，或者主节点发现从节点长时间没有请求数据更新，就可能认为对方出现了故障
    5. 故障转移：主从复制模式本身不自动进行故障转移。当主节点出现故障后，需要手动将从节点提升为主节点。若应用程序需要自动切换，可以在应用层编写代码来检测主节点故障，并手动执行命令将从节点升级为主节点，同时更新应用程序的连接配置
2. `哨兵模式`
    1. 在主从模式基础上，引入了哨兵节点。哨兵节点负责监控主从节点的状态，当主节点出现故障时，自动选举新的主节点，并通知从节点进行切换
    2. 配置管理：哨兵节点还负责管理主从节点的配置信息，如主节点的地址、从节点的列表等。当主节点发生故障转移后，哨兵节点会自动更新配置信息，确保客户端能够连接到新的主节点
    3. 应用场景：`适用于对高可用性要求较高的场景`，如金融系统、大型电商平台等。通过哨兵模式，可以在主节点出现故障时，自动快速地进行故障转移，保证系统的连续性和稳定性
    4. 哨兵节点：主要用于监控主从节点的状态，本身并不存储业务数据，只保存一些关于主从节点的配置信息和监控状态数据等
    5. 故障检测：哨兵节点会定期向主节点和从节点发送 PING 命令来检测它们的存活状态。如果在一定时间内没有收到节点的响应，哨兵节点就会认为该节点主观下线。多个哨兵节点之间会互相通信，交换对各个节点状态的判断，如果超过一定数量（quorum）的哨兵节点都认为主节点主观下线，那么就会将主节点标记为客观下线
    6. 故障转移：当主节点被判定为客观下线后，哨兵会在从节点中选举出一个新的主节点。选举依据包括从节点的优先级、复制偏移量等。选举出的从节点会被提升为主节点，其他从节点会重新配置，开始向新的主节点进行数据复制。同时，哨兵会将新主节点的信息通知给应用程序，以便应用程序更新连接配置
3. `集群模式`
    1. 采用无中心结构，每个节点都可以处理读写请求，数据通过哈希槽（Hash Slot）的方式分布在各个节点上，节点之间通过 Gossip 协议进行通信和数据同步
    2. 哈希槽：Redis 集群默认将数据空间划分为 16384 个哈希槽，每个键值对根据其键的哈希值映射到对应的哈希槽中，然后再由特定的节点负责存储和管理这些哈希槽
    3. 节点分配：在集群初始化时，会将这 16384 个哈希槽平均分配到各个节点上。当集群规模发生变化，如添加或删除节点时，会通过数据迁移操作，将哈希槽及其对应的数据从一个节点转移到另一个节点，以保证数据的均衡分布
    4. 应用场景：`具备高可用性`，`适用于处理大规模数据和高并发读写的场景`，如社交媒体平台、大型游戏平台等。通过集群模式，可以实现数据的分布式存储和负载均衡，提高系统的可扩展性和性能
    5. 各个节点：每个节点只负责存储整个数据集中的一部分数据，通过哈希槽的方式将数据分布到不同的节点上。例如，Redis 集群将数据空间划分为 16384 个哈希槽，每个键值对根据其键的哈希值映射到对应的哈希槽中，每个节点负责一部分哈希槽的管理和数据存储，不同节点存储的数据是不同的，它们共同组成了完整的数据集
    6. 故障检测：在 Redis Cluster 中，每个节点都会定期向其他节点发送 PING 消息，接收节点会回复 PONG 消息。如果一个节点在规定时间内没有收到某个节点的 PONG 消息，就会认为该节点疑似下线（PFail）。节点会将疑似下线的信息传播给其他节点，当半数以上的主节点都认为某个主节点疑似下线时，这个主节点就会被标记为已下线（Fail）
    7. 故障转移：当一个主节点被标记为已下线后，它的从节点会发起选举。从节点会向其他主节点发送选举请求，要求它们给自己投票。如果一个从节点收到了超过半数主节点的投票，它就会成为新的主节点，接管原主节点的槽和数据。其他节点会更新自己的配置，将请求路由到新的主节点上
    8. 自动进行数据迁移和故障转移 读写性能可随节点增加线性扩展


### 单点故障
1. 一个master节点有问题，其slave机器都完了，因此设置多个master节点。单线程，原子性


### 实现分布式锁
1. `分布式锁介绍`
   分布式锁的设计 redis分布式锁适用于集群场景，单实例使用jvm锁即可
   setnx命令，获取到锁，执行。获取不到锁，阻塞/返回/重试 思考：lock和trylock的区别
2. `可能存在的问题`
    1. redis分布式锁续期具体实现 业务时间过长redis分布式锁失效导致并发问题如何延长锁时间
    2. 分布式锁redis集群某实例坏了导致分布式锁失效:
       缓存集群是主从服务，主set key之后，从复制数据，会有io操作，耗时，一个连接获取到锁之后主挂了，从变成主但是还没来得及主从复制，另一个连接在主set key    
       成功竟然获取到锁了，导致分布式锁失效(redis集群不保证数据的高一致性)
       针对以上分布式锁失效场景，redisson通过redlock算法(上锁 保证所有redis节点都set成功才返回上锁成功 强一致性)，redis特有
    3. 因为业务执行时间过长导致锁过期从而导致并发问题 ：线程1释放锁 释放的是线程2持有的锁 因为锁是同一把(redis的同一个key) 这个要避免：使用uuid
3. `redisson` redis提供的分布式锁框架
    1. redisson是线程id和uuid绑定一起 从而保证线程不会释放另一个线程的锁
    2. watch dog看门狗：redis分布式锁续期具体实现 解决了锁过期但是业务没执行完的问题
    3. 兼容redis集群场景 集群场景只会向一个节点设置锁 返回上锁结果 然后集群内部后续进行主从同步
    4. 获取锁是自旋锁机制


### redis可重入锁
1. 和Java可重入锁概念类似
2. 使用场景：
    1. 递归函数调用：当一个函数可能会递归地调用自身，且在函数内部需要访问共享资源时，可重入锁可以保证在递归调用过程中，不会因为重复获取锁而导致死锁
    2. 资源访问控制：在多个线程或进程可能同时访问共享资源的场景中，如数据库连接池、文件读写等，可重入锁可以确保在同一时刻只有一个线程能够访问资源，避免数据冲突和不一致性


### 不同数据类型的应用场景