### jvm概述
熟悉jvm内部构造，学jvm为了了解jvm从而让Java程序更好的运行，最终进行Java系统性能优化。

**学习链路**  
`为了Java系统性能优化` -> `需要知道调优工具` -> `需要知道垃圾回收/垃圾回收器相关内容` -> `需要先知道jvm内存结构、class文件结构、类加载过程、执行引擎`

**jvm简介**  
`JVM(Java虚拟机)`是一个可以用于执行`Java字节码`的`虚拟机进程`，`jvm只接收字节码文件`，可以安装并运行在各操作系统  
一个JVM进程里是多个Java线程，`Java程序`在`jvm`上运行，Java语言底层运行环境就是`jvm`，Java源代码编译成Java字节码，Java字节码运行在JVM上  
Java程序一次编译后，在各操作系统运行不需要重新编译，只要该操作系统安装了`jvm`即可运行Java程序  
因此，Java语言是平台(操作系统)无关的编程语言，Java程序员不需要为不同的操作系统重新编码Java代码  
不同的编程语言经过自己的编译器编译后变成jvm能识别的字节码文件，jvm就都能运行，jvm是跨语言的平台  
`操作系统`是管理`计算机资源`的，`jvm`管理`jvm`的运行内存

**知道几款jvm**
1. sun公司`HOT SPOT虚拟机`
2. bea公司的`jrockit虚拟机`
3. ibm公司的`J9虚拟机`
4. `Graal VM` 是虚拟机的未来

**jvm生命周期**
1. jvm的启动(OS的一个进程)
2. jvm退出(进程退出了)


### 字节码篇
**hot spot jvm结构**
1. `类加载器子系统` 三个环节(每个环节做什么事):`加载` `连接` `初始化`
2. `运行时数据区`
    1. `方法区` 线程公有，jvm进程中的多个Java线程共有
    2. `堆` 线程公有，堆比栈的内存空间要大，但栈比堆的运算速度快
    3. `程序计数器` 线程私有
    4. `本地方法栈` 线程私有
    5. `虚拟机栈` 线程私有
        1. `局部变量表` `int a=1`、`形参变量`放局部变量表里
        2. `操作数栈`

3. `本地方法接口` 本地方法库
4. `执行引擎`
    1. `解释器`
    2. `即时编译器`
    3. `垃圾回收器`


**字节码文件(.class文件)**
`字节码文件`是跨平台的，jvm主要识别的就是字节码文件，jvm已经不和某一门语言深度耦合  
class文件不能打开看 存的是二进制类文件 `Java源码`->`编译`->`class文件`->`解释器`->`机器指令`  
`常见编译器`(能编译成字节码文件)：`Javac编译器` `全量编译器` `ecj编译器` `增量编译器`  
`一个class文件` 对应 `一个类`，`一个class文件`加载到内存中对应`一个class实例(即一个class对象)`  
`类` `接口` `枚举` `数组` `注解`都有对应`class对象`


**读懂字节码指令**
`字节码指令` = `操作码` + `操作数`  
字节码指令有哪些:小于256个  
为了读懂字节码指令与源代码的含义一一对应  
字节码指令根据用途分成9类：  
1. `加载与存储指令：` `局部变量压栈指令` `常量入栈指令` `出栈装入局部变量表指令`
2. `算术指令：` `算术指令` `比较指令`
3. `类型转换指令`
4. `对象的创建与访问指令`
5. `方法调用与返回指令(了解即可)`
6. `操作数栈管理指令`
7. `控制转移指令`
8. `异常处理指令`
9. `同步控制指令`


**解读class文件结构(idea下载插件 jclasslib Bytecode viewer 查看字节码文件)**
1. `魔数` 表明是字节码文件 字节码文件魔数都一样
2. `class文件版本`
3. `常量池`
4. `访问标识` `类的声明` public final
5. `类索引` `父类索引` `接口索引集合`
6. `字段表集合`
7. `方法表集合`
8. `属性表集合`

**jvm数据类型**  
1. 基本类型
2. 引用类型
3. 方法返回地址类型

为什么不把基本类型放堆中？简单数据类型比较稳定，并且它只占据很小的内存，将它放在空间小、运算速度快的栈中，能够提高效率


### 类的加载篇
`类加载`是指将类的字节码文件加载到内存中，并将其转换为 JVM 可以使用的 Class 对象的过程  
`类加载器子系统(在Java内存中)`：就是负责类加载的，负责从文件系统中加载字节码文件到JVM

字节码文件进入JVM，类加载器子系统三个环节(类的加载过程)：
1. `加载阶段`
2. `链接阶段`
    1. `验证`
    2. `准备`
    3. `解析`
3. `初始化阶段`

**注意**
1. `class实例(在堆中)`:就是对象实例  
2. `类模板对象(在方法区)`:一个class文件加载到内存只有一个`类模板对象`，即`反射的class对象``类对象`
3. `类的元数据(在方法区)`:`类的元数据`指`类的方法代码``变量名`，`方法名`，`访问权限`，`返回值`等等，`class对象`是`类元数据`的核心部分，但不是全部
4. `方法区`=`元空间`=`永久代`

从`class文件`到`加载到内存中的类`，到`类卸载出内存`为止，`类的整个生命周期`包括如下`7个阶段`:  
1. `加载阶段`  
    `类加载器只在该阶段有用` 类加载器作用就是通过`双亲委派机制`加载`class文件`成内存的`类模板对象`  
    `class文件`到内存中，生成一个`类模版对象`，放在jvm内存的`方法区`，对象实例放在`堆`  
    反射就是获取`类对象`的 如果`类对象`没进内存 则无法反射  
2. 链接阶段
    1. `验证`  
        合法性验证：类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等(格式验证会和`1.加载阶段`一起执行)
    2. `准备`  
        为类的静态变量分配内存，并将其初始化为默认值，常量是字面量时在此阶段给值
    3. `解析`(一般`3.初始化`完成之后再执行)
        简言之，将类、接口、字段和方法的符号引用(字节码文件中的引用形式)转为直接引用(真正引用) 得到对应真实内存的地址  
        链接阶段完成前只能处理基本类型和字面量
3. `初始化阶段`
    调用init方法  
    为类的静态变量赋予正确的用户定义的初始值  
    常量 给的值是方法返回值时 在该阶段给值  
    `该过程可能会死锁`:两个线程 类加载时会调用并锁住init()线程安全  线程1加载类a、b  线程2 加载类b、a 此时死锁
4. `使用`
5. `卸载:`类加载器会记录哪些class对象是我加载的

**关于类的整个生命周期面试常问**
1. 每个阶段都做了什么事
2. 类只会加载一次吗 内存已有还加载吗 ？一个类加载器只加载一次 多个类加载器可以加载多次
3. 都谁需要加载？在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义加载到内存，引用数据类型则需要进行类的加载到内存

被动的使用类，意味着不需要执行初始化坏节，意味着没有<clinit>（）的调用  

**类的加载时机(会读取相应class文件到内存并最终初始化 主动使用类 主动找class文件)**  
1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化
2. 当调用类的静态方法时，即当使用了字节码invokestatic指令
3. 当使用类、接口的静态字段时(fina1修饰特考虑)，比如，使用getstatic或者putstatic指令
4. 当使用java.lang.reflect包中的方法反射类的方法时。比如:Class.forName("com.***.java.Test")
5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化
7. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的那个类)，虚拟机会先初始化这个主类

**类的加载分为：**
1. `显式加载:`代码写了
2. `隐式加载:` `自动加载` `被动加载` `输出类`

**类加载机制有三个基本特征**
1. `双亲委派模型`
2. `可见性:`子类加载器可以访问父加载器加载的类型
3. `单一性:`由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载

**类加载器分类(两类)**
1. `启动类加载器`
2. `继承classloader的 自定义类加载器`

**类加载器有哪些**
1. 引导类加载器
2. 扩展类加载器
3. 系统类加载器
4. 用户自定义类加载器

**类加载器源码分析**
- 有父类加载器
- loadclass方法 双亲委派机制

**双亲委派机制**
谁加载一个类  
类加载器是有上下级的  
一个类加载 保证一个class对象(来自class文件)在内存空间的唯一性  
先找父类加载器加没加载过 加载过则访问用该类 否则向上找 找到顶级后 顶级判断这个类应该我加载吗 是则加载 否则向下委派!!!  
类加载使用的类加载器  
`静态代码块在所在类加载时执行`  

`自定义类加载器:`一个类加载器一个类只加载一次(class对象内存中只有一个) 为了一个类加载多次 手写类加载器  

`双亲委派机制好处:`避免类重复加载 防止核心api被篡改 tomcat违背了双亲委派机制


**打破双亲委派机制的方式**


### jvm运行时内存篇(jvm内存结构)
jvm运行内存几大内存区域：运行时数据区(5个)

**注意**  
1. `垃圾回收GC`: 只涉及`方法区` `堆`
2. `内存溢出oom` 只涉及`方法区` `堆` `虚拟机栈` `本地方法栈`
3. `内存泄漏`：明明是垃圾但不帮回收
4. 方法中定义的局部变量是否线程安全？ 不一定 要看指向堆中的对象 如果栈帧出栈局部变量指向的堆中对象不销毁则线程不安全

**注意**
1. `存活对象`
2. `已经死亡的对象(垃圾)`：当一个对象已不再被任何存活对象继续引用时，即在运行程序中没有任何指针指向的对象，就可以宜判为已经死亡


**面试题**
1. 新生代 s0 s1 有什么用


1. `堆` `堆管存储` `内存空间大` `慢` `存放的东西和栈不一样` `有gc` `会oom`  
    `字符串常量`在`字符串常量池`里，`字符串常量池`在`堆`里  
    Java7以后`字符串常量池`放在了堆空间，定义字面量是常量池 先去堆空间找如果存在则使用 所以内存地址相同    
    `线程共享`，运行内存中最大的一块，虚拟机启动时创建，该区域的唯一目的是存放`对象实例`，比如new Object()，申请一些内存空间  
    堆是内存回收的重点关注的地方  
    方法结束后 堆中对象不会马上被移除 仅仅`在垃圾收集的时候`才会被移除  
    `jdk7`:
    1. `堆空间：`
        1. 新生代(生命周期很短) 1
            1. s0区(from区) 1
            2. s1区(to区) 1
            3. 伊甸园区(eden区) 8
        2. 老年代(生命周期很长) 2 比如runtime对象
    2. `方法区`：永久代,jdk7逻辑上把方法区看作堆空间一部分  
    `Java8之后``方法区`又叫`元空间` `永久代`又叫`元空间`
    几乎所有的Java对象都是在`Eden区`被new出来的，没被回收掉的到`s0区`，还没回收掉的到`老年代`  
    大对象不是在eden区创建的 直接进入老年代  

    怎么`设置堆大小` 通过参数 `-xms堆初始大小`  `-xmx堆最大大小`  
    通常会将 -Xms 和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完推区后不需要重新分隔计算堆区的大小，从而提高性能  
    新生代/老年代内存大小占比=1/2  
    默认-XX: NewRatio=2表示新生代占1，老年代占2，新生代占整个堆的1/3  
    在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1

    对象分配情况：给对象分配内存 放在堆中哪个区域  
    gc:频繁在新生区收集 很少在养老区收集 几乎不在永久区/元空间收集  
    对象分配过程：一开始放在eden区，eden区空间不足后，发生新生代gc，删除eden区一些对象后，eden中其余对象放到s0区，  
    eden区又满了之后，发生新生代gc，删除eden区 s0区一些对象后，其余的 eden和s0中的都弄到s1区，  
    eden区又满了之后，发生新生代gc，删除eden区 s1区一些对象后，其余的 eden和s1中的都弄到s0区，  
    以此往复，当年龄达到15还没删除时就放到老年代，对象每换一次区域年龄加1，  
    老年代满了之后发生major gc 删除老年代对象，老年代还是满了就oom内存溢出

    对象内存分配原则：  
    针对不同年龄段的对象分配原则如下所示：  
    优先分配到Eden  
    大对象新生代放不下直接分配到老年代 尽量避免程序中出现过多的大对象  
    长期存活的对象分配到老年代

    动态对象年龄判断:  
    如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，  
    年龄大于或等于该年龄的对象可以直接进入老年代，无须等到  
    MaxTenuringThreshold 中要求的进入老年代的年龄

    空间分配担保 很复杂的策略逻辑 对象回收以及放到老年代的一个策略机制 -XX: HandlePromotionFailure

    Minor GC ：新生代gc 只回收新生代的对象 只有eden区满了会触发minor gc  

    非Minor GC(major gc) ：老年代gc 只回收老年代对象  
    就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC  
    Major GC 后，内存还不足，就报OOM了  

    空间分配担保策略 -XX:HandlePromotionFailure  

    为什么需要把Java堆分代？不分代就不能正常工作了吗  
    分代的唯一理由就是优化GC性能!!!  
    如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。  
    GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描  
    而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，  
    这样就会腾出很大的空间出来  

    TLAB:  
    把内存分配的动作按照线程划分在不同的空间之中进行，  
    即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，  
    (TLAB，Thread LocalA1location Buffer)虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定

2. `方法区`
    加载到内存的类元数据(类结构信息)放在方法区  
    `线程共享`，用于存储已经被虚拟机加载的 类信息，静态成员变量(静态变量随着类加载而加载)  
    在jdk7及以前，习惯上把`方法区`，称为`永久代`。jdk8开始，使用`元空间`取代了`永久代`    
    `本地内存` `虚拟机层面的运行内存` 注意两者概念  
    方法区的大小决定了系统可以保存(加载)多少个类，如果系统定义了太多的类，导致方法区溢出  
    设置方法区内存的大小 jvm参数 <=java7 -XX:MaxPermSize >=java8 -XX：MetaspaceSize  

    为什么永久代被元空间替换？元空间使用本地内存 可劲用 加载多少类都没事  
    7/8中：字符串常量 静态变量放到堆中 字符串频繁创建 在堆中容易回收 永久代回收效率不高  
    6中：静态变量放在方法区  

3. `程序计数器` `jvm内存最小的一块区域`  
    线程私有，一块较小的内存空间，作用是：当前线程所执行的字节码的行号的一个指示器，记录每个线程执行到哪了  
    只记录运行下一行的地址`没有GC垃圾回收`。唯一没有`OOM内存溢出`的区域。没有error
    使用pc寄存器存储字节码指令地址的用处：线程上下文切换之后从哪里继续执行，记录当前线程执行地址  

4. `虚拟机栈` `管运行` `内存空间小于堆` `快` `没有gc` `会oom`  
    虚拟机栈大小可以参数设置 栈大小设置太大会导致能创建线程总数变少  
    `线程私有`，生命周期与线程相同 虚拟机栈保存对象引用地址  
    虚拟机栈内存模型：描述的是Java方法执行，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息  
    每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  
    JVM栈可能的异常：栈溢出异常，内存溢出异常。  
    每个线程创建时会有一个虚拟机栈，里面是栈帧，栈帧 -- 一个方法。  

    没有垃圾回收 因为方法结束就出栈了。但仍可能有OOM内存溢出。 一般及时垃圾回收就没有内存溢出!!!  
    栈溢出情况 典型递归：固定栈大小时可能会栈溢出，栈帧太多超出最大大小，栈扩容时扩不了或新线程创建栈创建不了时会内存溢出OOM  

    栈帧构成：  
    1. 局部变量表 是一个数组 方法里的变量 局部变量表和操作数栈大小在字节码文件中就可以确定了  
        基本类型 引用类型(指向堆中对象) 方法执行完方法里的变量就不存在了
    2. 操作数栈  
        没有垃圾回收  
        局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。常量入操作数栈  
        操作数栈出栈存回局部变量表  
        操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间  
        栈顶缓存技术：将操作数栈顶元素全部缓存在物理CPU的寄存器中 因为cpu总和操作数栈交互  
    3. 动态链接  
        标识该栈帧所属方法是哪一个  
    4. 方法返回地址  
        无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置  
        方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。  
        而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。  
    5. 一些附加信息

5. `本地方法栈` `线程私有` `栈帧是本地方法(c语言api)`

### 对象内存布局结构
**对象创建方式**  
1. `new`
2. `反射`
3. `clone` 浅拷贝：经过浅拷贝的对象 其成员变量地址相同 是同一个成员变量
4. `反序列化` 文件数据库中的二进制流 反序列化为内存中的对象

**创建对象步骤**  
1. 判断对象对应的类是否加载、链接、初始化
2. 为对象分配堆内存空间
    指针碰撞方式 以指针寻找应该将对象放在哪里  
    空闲列表方式 记录堆空间中哪些位置是空闲的
3. 处理并发安全问题
    多个线程共用堆空间 多个线程访问空闲堆空间可能出现并发问题 解决：cas TLAB
4. 初始化分配到的堆空间
    初始化成员变量为0值
5. 设置对象的对象头
6. 执行init方法进行初始化
    初始化成员变量为程序员定义的值，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

**対象的内存布局(对象实例内部结构)**  
1. `对象头`
    1. 运行时元数据
        1. 哈希值 记录对象在堆中的内存地址
        2. gc分代年龄：对象的年龄
        3. 锁状态标志：是否加锁了 用于实现同步的标记位 用于标记对象的同步状态
    2. 类型指针 指向方法区类对象的指针(使用直接指针访问方式)
2. `实例数据`：成员变量和父类成员变量
3. `对齐填充`

**对象的访问定位：虚拟机栈栈帧局部变量表里的变量引用指向堆对象 怎么访问堆对象的？**
1. 使用句柄访问：访问堆空间句柄池 句柄池存储到对象实例数据的指针
2. 使用直接指针访问

### 执行引擎篇
`执行引擎`-jvm结构的一部分 包含：`解释器` `即时编译器` `垃圾回收器`  
方法调用执行 需要执行引擎  

执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以，相当于翻译  
解释器：对字节码采用逐行解释的方式执行 将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。  
JIT 即时编译器 是动态编译：对字节码文件中的热点代码提前翻译好成机器指令`缓存`起来 到时候直接用  
hot spot jvm是 解释器+jit并存 的架构 因为解释器还是针对某些场景更方便!!!  
热点代码：方法调用计数器  

aot编译器：与即时编译相对立的一个概念 在程序运行之前，便将字节码转换为机器码的过程。是静态编译  

静态编译缺点：最终成机器码了 不像字节码跨平台了 动态编译有可优化点 静态编译不存在优化了!!!  
hot spot jvm 执行引擎默认解释器+jit模式，可以修改仅解释器，仅jit，看代码执行时间，  
在HotSpot VM中内嵌有两个JIT编译器 c1编译器 c2编译器 c1c2两种jit编译器优化方式策略不一样  
jvm默认启动模式：解释器+jit  


**垃圾回收gc(JVM内存回收，对应`内存分配`)**
`为什么gc`:  
1. JVM运行内存是有限的，为了Java程序在JVM良好运行，需要内存回收
2. 有内存碎片问题 需要整合供大内存对象分配

`频繁收集新生代` `较少收集老年代` `基本不动元空间` 这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准

**关注几点**  
1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

在`堆`里存放着几乎所有的`java对象实例`  
在`GC`执行`垃圾回收`之前，首先需要区分出内存中哪些是`存活对象`，哪些是`已经死亡的对象`  
垃圾回收器只回收垃圾：只有被标记为`己经死亡的对象(垃圾)`，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间  死两天也没被回收(释放内存空间)也有可能!!!  
因此这个过程我们可以称为垃圾标记阶段    


**垃圾回收算法**

**垃圾判别阶段算法**
1. `引用计数算法`  
    引用计数算法比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况  
    缺点：循环引用时内存泄漏  
2. `可达性分析算法(根搜索算法)`
    凡是和根root能关联的对象 不是垃圾  
    没有循环引用问题 也可能内存泄漏  
    哪些是根root:
    1. 各个线程被调用的方法中使用到的参数、局部变量等(局部变量表)，对应本地方法栈的局部变量表
    2. Java类的引用类型静态变量
    3. 字符串常量池(String Table)里的引用
    4. 被同步锁synchronized持有的对象
    5. Class对象
    6. 一些常驻的异常对象
    可达性分析算法要停止用户线程 否则不准了 因为局部变量表可能变化
3. `三色标记算法`(CMS、G1等垃圾回收器使用)


**垃圾清除阶段算法**
1. `标记-清除算法`
    使用可达性分析算法把不是垃圾的标记，未标记的清除，  
    缺点：内存碎片化 需要停止用户线程 用户体验不好  
2. `复制算法`
    使用可达性分析算法把不是垃圾的标记，标记好的放到另一空间，原空间全部清空，  
    好处 不会内存碎片化 但需要两倍内存空间 指针重新记录
3. `标记-压缩算法`
    使用可达性分析算法把不是垃圾的标记，指针碰撞形式把不是垃圾的对象放在一起，其余空间清除，  
    消除了 1 2 的缺点 还需要暂停用户线程
4. `分代收集算法`
    不是一种算法，而是不同年龄的对象采用不同的垃圾清除算法，  
    老年代：一般是由标记-清除或者是标记-清除与标记-压缩的混合实现  
    年轻代：复制算法适用

`finalize()` 当一个对象首次考虑要被回收时，会调用其finalize() 遗言 听我一言 也可能对象不是垃圾 对象销毁前调用 一般在这里释放资源

`内存泄漏` 一个对象是垃圾但是不给回收，还有一个是对象本来该死但是没死也叫内存泄漏  
`导致内存泄漏的情况：`  
1. 静态集合类 成员方法中局部变量new 然后add
2. 连接资源 io流 如果不用了 但始终有引用 不会回收 内存泄漏
3. 变量不合理的作用域

静态成员变量和类的生命周期一样 类一般不会gc

`内存溢出` 内存回收速度赶不上内存分配的速度 内存满了。oom之前必gc吗 不一定 大对象

`垃圾回收的并行并发`：
多个垃圾回收线程同时执行就是`并行` 一个就是`串行`，垃圾回收线程和用户线程都在执行:`并发`  
独占式：用户线程和gc线程不一起执行


**对象的强弱软虚引用**  
1. `强引用`：不回收 gc也不回收 最后就oom
2. `软引用`：gc时内存不足即回收 比如缓存数据
3. `弱引用`：gc即回收 比如可有可无的缓存数据
4. `虚引用`：


**垃圾回收器**

**垃圾回收器分类：**
1. `串行` `并行`
2. `并发式` `独占式`
3. `压缩式` `非压缩式`
4. `针对新生代` `针对老年代`

**垃圾回收器评估指标：**
1. `吞吐量`：程序的运行时间/（程序的运行时间＋内存回收的时间） 越大越好
2. `暂停时间`：执行垃圾收集时，程序的工作线程被暂停的时间 每个垃圾回收器一定都有暂停时间的
3. `收集频率`：相对于应用程序的执行，收集操作发生的频率。
4. `Java堆区所占的内存大小`

`吞吐量`和`暂停时间`一般不能同时满足 JVM调优标准：在最大吞吐量优先的情况下，降低停顿时间

**垃圾回收器有哪些(7种) 不同的垃圾回收器有不同适用场景**
1. 串行回收器：`Serial(串行回收 复制算法 Stop-the-World机制)`，`Serial Old(标记-压缩算法 串行回收 stw机制)`
2. 并行回收器：`ParNew(并行回收 复制算法 Stop-the-World机制)`，`Parallel Scavenge(并行 stw 复制算法 主打吞吐量)`，`Parallel Old(并行 标记-压缩算法 stw)`
3. 并发回收器：`CMS(标记-清除算法 stw 主打低延迟 不是内存不足时才gc，到达一定阈值gc)`，`G1`

`Serial` ，`ParNew`，`Parallel Scavenge` 是收集新生代的  
`Serial Old`，`Parallel Old`，`CMS` 是收集老年代的


**关于G1垃圾回收器**
1. 在 JDK 7 Update 4 及以上版本正式引入，旨在满足大内存、多处理器系统的需求，尤其适用于具有大堆内存和高并发的场景
   打破了传统的`分代式垃圾回收器`将堆内存严格划分为新生代和老年代的做法，
   它将整个堆内存划分为多个大小相等的独立区域(Region)
2. `G1工作流程`
3. `垃圾判别算法`是`三色标记算法`
4. (特点)G1 采用标记 - 整理算法，在回收过程中会进行内存的整理，避免了内存碎片的产生，有利于大对象的分配
5. G1垃圾回收器是并发垃圾回收器，即用户线程和垃圾回收线程都在执行(并行并发特点)
6. G1回收新生代也回收老年代
7. Java9以后是G1
8. G1主打吞吐量 低延迟 并行并发都支持 分代收集 整体上实际可看作是标记-压缩算法 关注G1相关参数设置
9. G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：
    1. 开启G1垃圾收集器 -XX:+UseG1GC
    2. 设置堆的最大内存 -XX:G1HeapRegionSize=n，n 可以是 1MB、2MB、4MB 等，G1 会根据堆内存大小自动调整默认的 Region 大小
    3. 设置期望的最大停顿时间(特点) -XX:MaxGCPauseMillis
10. G1 GC的垃圾回收过程主要包括如下三个环节：
     1. 年轻代gc
     2. 老年代并发标记过程
     3. 混合(整个新生代部分老年代)回收
11. `适用场景`：
    1. 堆内存较大：G1 能够更好地管理内存，避免传统垃圾回收器在大内存场景下的性能问题
    2. 对响应时间敏感的应用


**垃圾回收器`CMS`、`G1`相同点&区别**
1. `垃圾判别`都是使用`三色标记算法`
2. 都是`并发回收器`
3. `堆内存划分有区别`
    1. CMS：传统的分代式设计，将堆内存严格划分为新生代和老年代，新生代又可细分为 Eden 区和两个 Survivor 区。不同代使用不同的垃圾回收算法，新生代一般使用复制算法，老年代使用标记 - 清除算法。
    2. G1：打破了传统的分代划分方式，将整个堆内存划分为多个大小相等的独立区域（Region）。每个 Region 可以根据需要动态地扮演 Eden 区、Survivor 区或老年代的角色，同时还存在专门存储大对象的 Humongous Region
4. `工作流程区别`
5. `垃圾回收算法区别`
    1. CMS：老年代采用标记 - 清除算法，该算法在清除垃圾对象后会产生内存碎片，可能导致后续大对象分配时因找不到连续内存空间而触发 Full GC。
    2. G1：整体上采用标记 - 整理算法，局部（Region 间）采用复制算法。标记 - 整理算法在回收垃圾的同时会对内存进行整理，避免了内存碎片的产生，有利于大对象的分配。
6. `停顿控制区别`：CMS难以精确控制垃圾回收时间，而G1可以
7. `应用场景区别`
    1. CMS：适用于对响应时间有一定要求、停顿时间较短、堆内存不是特别大（一般在 4GB - 6GB）的应用场景，例如一些传统的 Web 应用服务器。
    2. G1：更适合大内存、多处理器的系统，当堆内存较大（通常超过 4GB）且应用对响应时间有较高要求时，G1 能够发挥更好的性能，如大型企业级应用、分布式系统等


未来是ZGC


**垃圾回收器搭配使用：**
`Serial`/`Serial Old`  
`Serial`/`CMS`
`ParNew`/`Serial Old`
`ParNew`/`CMS`
`Parallel Scavenge`/`Serial Old`
`Parallel Scavenge`/`Parallel Old` Java8默认的垃圾回收器组合

查看默认gc:-XX：+PrintCommandLineFlags

**查看某jvm进程使用的垃圾回收器是哪个：**  
1. 使用jconsole 运行jconsole选择当前正在运行的jvm 查看垃圾回收器
2. 使用jps 列出当前进程 jinfo pid 查看某一个jvm应用的所有vm参数 这些参数里标明了用的垃圾回收器

垃圾回收器配置相关可以通过设置vm参数

关注各个GC适用场景

**GC日志分析**
- GC日志文件参数
- GC日志文件分析工具

### jvm性能监控篇(实用性)


### jvm性能调优案例(实用性)

**为什么jvm调优(为了提升 Java 应用程序的性能、稳定性，减少响应时间和内存占用)**  
1. `预防问题` 防止出现OOM，进行JVM规划和预调优
2. `解决问题` 解決程序运行中各种oom
3. 系统更快 承受压力更大

**调优的大方向：**调优，从业务场景开始，没有业务场景的调优都是耍流氓！无监控，不调优!  
1. `合理规范编写代码`
2. 充分并合理的使用`硬件资源`
3. 合理地进行`JVM调优`


**一些OOM问题(jvm运行内存满了):**
1. `堆溢出`：`java.lang.OutOfMemoryError: Java heap space`
    `分析可能原因`：`对象太多` `大对象` `内存泄漏`
    `解决方案`：`检查是否有大对象` `分析dump文件` `加大堆内存`
    还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性

2. `元空间溢出`
    元空间内存回收目标主要是针对`常量池的回收`和`对类型的卸载`
    `分析可能原因`：
    1. 运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载
    2. 应用长时间运行，没有重启
    3. 元空间内存设置过小

    `解决方案`：  
    1. 元空间内存是否过小
    2. 检查代码中是否存在大量的反射操作
    3. dump之后通过mat检查是否存在大量由于反射生成的代理类

3. `GC overhead limit exceeded` 频繁gc但是gc只回收了小部分的空间 频繁gc但是回收不了 抛出该异常时系统没有真正的内存溢出 是预判性报错
    `分析可能原因`：是否内存泄漏  
    `场景`：向List不断添加字符串元素 i+="aa" 这种会回收原来的字符串常量
    `解决方案`：如果代码没问题 可以关掉这个参数 就不报这个错了 或者`加大内存`

4. `线程溢出` 无法再创建线程 java.lang.OutOfMemoryError: unable to create new native Thread
    `分析可能原因`：线程太多导致


**调优监控的依据：**  
1. 运行日志
2. 异常堆栈
3. GC日志
4. 线程快照
5. 堆转储快照 dump文件


**性能优化的步骤(重点!)：**  
1. `熟悉业务场景`
2. `发现问题` 通过性能监控发现问题
    1. `GC频繁`
    2. `cpu load过高`
    3. `OOM`
    4. `内存泄漏`
    5. `死锁`
    6. `程序响应时间较长`

3. `排查问题`：性能分析 (gc日志，命令行工具，jstack,jmap,jinfo等，dump出堆文件，arthas)
4. `解决问题`：性能调优
    1. 堆内存调优
        1. 适当增加内存 合理设置堆大小
        2. 调整新生代和老年代比例 -XX:NewRatio=2
    2. 垃圾回收器调优
        1. 根据业务背景选择垃圾回收器
        2. 调整垃圾回收器参数 -XX:CMSInitiatingOccupancyFraction 设置老年代使用达到该比例时触发 CMS 垃圾回收
    3. 优化代码，控制内存使用
        1. 避免内存泄漏
        2. 减少大对象的创建
        3. 优化对象的生命周期
    4. 硬件资源优化：增加机器，分散节点压力
    5. 合理设置线程池线程数量
    6. 使用中间件提高程序效率，比如缓存，消息队列等


**调优案例1-调整堆大小提高服务的吞吐量**  
设置`vm参数堆大小`  jmeter中查看服务吞吐量

**调优案例2-JVM优化之JIT优化**  
通过设置`vm参数` 可以对JIT编译器进行优化使代码执行更快  
即时编译对代码的优化：  
1. 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用 。是否判断逃逸分析是一个vm参数  
    如果当前的obj引用声明为static的，会发生逃逸吗？会！
2. 没有发生逃逸可以使用栈上分配 栈上分配：对象不在堆分配  
    只要开启了逃逸分析，就会判断方法中的变量是否发生了逃逸。如果没发生逃逸，则会使用栈上分配 最终效果是代码执行速度提升!!!
3. 同步省略(消除)
4. 标量替换
    结论：Java中的逃逸分析，其实优化的点就在于对栈上分配的对象进行标量替换。

**调优案例3-合理配置堆内存**  
如何计算老年代存活对象空间大小  
你会估算YGC频率吗  
结论：但当内存相对宽裕的时候，可以相对给服务多增加一点内存，可以减少GC的频率，  
GC的耗时相应会增加一些。一般要求低延时的可以考虑多设置一点内存，对延时要求不高的，可以接照上述方式设置较小内存。

**调优案例4-CPU占用很高排查方案**

**调优案例5-G1并发执行的线程数对性能的影响**

**调优案例6-调整垃圾回收器提高服务的吞吐量**

**调优案例7-日均百万级订单交易系统如何设置JVM参数**


### JVM参数
- `-ХХ:+PrintGCDetails` 打印垃圾回收相关信息
- `-XX:MetaspaceSize=64m` 设置元空间大小
- 显示程序运行过程堆栈信息的文件 叫dump文件 生成dump文件方式：
    - 手动 jmap -dump:format=b,file= <filename.hprof> <pid>
    - 自动生成 -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap/heapdump.hprof
- `-XX:+PrintGCDateStamps`
- `-Xms200M` 堆空间初始大小
- `-Xmx200M` 堆空间最大大小
- `-Xss512K` 栈空间大小
- -Xloggc:1og/gc-oomHeap.log GClog文件的路径 GClog文件直接打开看就行了
- `-XX: +TraceClassLoading` 加载的类打印
- `-XX: +TraceClassUnloading` 卸载的类打印(这个+号是开启的意思)
- `-XX：+UseAdaptivesizePolicy`


### jvm分析工具(用于jvm监控)
1. `Java VisualVM` jdk自带程序 在bin目录下 启动 打开dump文件 即可使用该程序分析dump文件  
    dump文件显示内容：  
    1. 类总数：7,341
    2. 实例总数：1,002,912
    3. 类加裁器：40
    4. 垃圾回收根节点：2,710
    5. 等待结束的暂挂对象数：0 

    在出现 OutOfMemoryError 异常错误时进行了堆转储  
    导致 OutoflemoryError 异常错误的线程：http-nio-8080-exec-1

2. `jmeter` 压力测试工具
3. `Prometheus`
4. `Grafana`


### jvm相关命令(用于jvm监控与分析 JVM 的运行状态，分析内存使用、垃圾回收情况、线程状态等)
1. `jstat -gc` 查看当前状态下gc信息
2. `jps` 查看当前运行的进程
3. `jinfo -flag ThreadStackSize 5016` 获取某一个jvm应用的所有vm参数
4. `jmap`
5. `javac .java` 编译Java文件
6. `jstack`